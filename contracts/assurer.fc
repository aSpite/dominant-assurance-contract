#include "imports/stdlib.fc";
#include "constants.fc";

global int storage::created_time;
global slice storage::author_address;
global int storage::init?;
global int storage::goal;
global int storage::donate_amount;
global int storage::guarantee_amount;
global int storage::participants_count;
global int storage::donated_count;
global int storage::valid_until;
global cell storage::donators;

() load_data() impure {
    slice ds = get_data().begin_parse();

    storage::created_time = ds~load_uint(32);
    storage::author_address = ds~load_msg_addr();
    storage::init? = false;

    if(slice_bits(ds) > 0) {
        storage::init? = true;
        storage::goal = ds~load_coins();
        storage::donate_amount = ds~load_coins();
        storage::guarantee_amount = ds~load_coins();
        storage::participants_count = ds~load_uint(8);
        storage::donated_count = ds~load_uint(8);
        storage::valid_until = ds~load_uint(32);
        storage::donators = ds~load_dict();
    }
}

() save_data() impure {
    set_data(begin_cell()
            .store_uint(storage::created_time, 32)
            .store_slice(storage::author_address)
            .store_coins(storage::goal)
            .store_coins(storage::donate_amount)
            .store_coins(storage::guarantee_amount)
            .store_uint(storage::participants_count, 8)
            .store_uint(storage::donated_count, 8)
            .store_uint(storage::valid_until, 32)
            .store_dict(storage::donators)
            .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    cs~skip_bits(4); ;; flags
    slice sender = cs~load_msg_addr();

    load_data();
    if(~ storage::init?) {
        throw_unless(error::unauthorized, equal_slices(storage::author_address, sender));
        storage::goal = in_msg_body~load_coins();
        storage::guarantee_amount = in_msg_body~load_coins();
        storage::participants_count = in_msg_body~load_uint(8);
        storage::valid_until = in_msg_body~load_uint(32);
        storage::donate_amount = storage::goal / storage::participants_count;
        storage::donated_count = 0;
        throw_unless(error::small_funding_amount, storage::goal >= const::min_funding_amount);
        throw_unless(error::small_guarantee_amount,
            storage::guarantee_amount * 100 / storage::goal >= const::min_guarantee_percentage);
        throw_unless(error::big_guarantee_amount,
            storage::guarantee_amount * 100 / storage::goal <= const::max_guarantee_percentage);
        ;; 8 bits can hold a maximum number of 255, but this is a check for the
        ;; future if you need to change the contract for a larger number of participants
        throw_unless(error::many_participants, storage::participants_count <= 255);
        throw_unless(error::big_funding_period, storage::valid_until - now() <= const::max_funding_period);
        throw_unless(error::small_donate_amount, storage::donate_amount >= const::min_donate_amount);
        ;; TODO: Handle storage and deploy fees
        throw_unless(error::not_enough_coins, msg_value >= storage::guarantee_amount);

        save_data();
        return();
    }
}
